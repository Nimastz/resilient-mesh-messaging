# services/routing_service/routing_api.py
# takes envelopes in, checks TTL / IDS, and talks to the DB + router loop.

from __future__ import annotations
import os
import asyncio
import json
from pathlib import Path
from typing import Optional
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, Depends

from .config_loader import ROUTING_CFG
from lib.envelope import MessageEnvelope
from lib.errors import http_error, ErrorCode
from lib.auth import DEVICE_FP_HEADER, DEVICE_TOKEN_HEADER, verify_api_token
from lib.utils import hash_token, current_unix_ts, validate_ttl

from .router_db import init_db, enqueue_message, get_outgoing, mark_delivered
from .router_loop import routing_loop
from .ids_module import is_rate_limited, is_duplicate, log_suspicious

IDS_LOG_PATH = Path("routing_suspicious.log")
DEBUG_MODE = os.getenv("ROUTER_DEBUG", "0") == "1"

app = FastAPI()

# ---------------------------------------------------------------------------
# Device auth
# ---------------------------------------------------------------------------

# Simple dev credential for now; in production this would come from a device DB.
DEV_DEVICE_FP = "DEV-ROUTER-CLIENT"
DEV_DEVICE_TOKEN = "dev-router-token"
DEV_DEVICE_TOKEN_HASH = hash_token(DEV_DEVICE_TOKEN)

# Optional: role-based access so debug/admin endpoints can be restricted later.
DEV_DEVICES = {
    DEV_DEVICE_FP: {
        "token_hash": DEV_DEVICE_TOKEN_HASH,
        # For a real deployment you’d separate roles (gateway, ble, admin).
        # Here we keep it simple but still have the mechanism.
        "roles": {"gateway", "ble", "admin"},
    }
}


def _base_auth(request: Request) -> str:
    """
    Core device auth: verify headers + token.
    """
    device_fp = request.headers.get(DEVICE_FP_HEADER)
    token = request.headers.get(DEVICE_TOKEN_HEADER)

    if not device_fp or not token:
        raise http_error(
            status_code=401,
            code=ErrorCode.UNAUTHORIZED,
            detail="Missing device auth headers",
            retryable=False,
        )

    dev_info = DEV_DEVICES.get(device_fp)
    if not dev_info or not verify_api_token(token, dev_info["token_hash"]):
        raise http_error(
            status_code=401,
            code=ErrorCode.UNAUTHORIZED,
            detail="Invalid device credentials",
            retryable=False,
        )

    return device_fp


def require_device_auth(request: Request) -> str:
    """
    Default dependency: just authenticates device, no role check.
    """
    return _base_auth(request)


def require_device_auth_role(role: str):
    """
    Factory returning a dependency that requires a specific device role.
    Use like: device_fp: str = Depends(require_device_auth_role("admin"))
    """
    async def _dep(request: Request) -> str:
        device_fp = _base_auth(request)
        dev_info = DEV_DEVICES.get(device_fp) or {}
        roles = dev_info.get("roles", set())
        if role not in roles:
            raise http_error(
                status_code=403,
                code=ErrorCode.FORBIDDEN,
                detail=f"Device missing required role: {role}",
                retryable=False,
            )
        return device_fp

    return _dep


# ---------------------------------------------------------------------------
# Timestamp helper (shared between enqueue + BLE ingress)
# ---------------------------------------------------------------------------

# Hard safety caps to prevent misconfiguration from disabling freshness checks.
_HARD_MAX_SKEW = 3600        # 1 hour
_HARD_MAX_AGE = 24 * 3600    # 24 hours


def _validate_timestamp_or_raise(msg_ts: int, peer: str, msg_id: str) -> None:
    """
    Enforce timestamp freshness with sane upper bounds.

    Raises http_error on hard failures (future too far).
    For "too old" we let callers decide whether to drop logically or error.
    """
    now = current_unix_ts()

    cfg_skew = ROUTING_CFG.get("max_ts_skew_seconds", 300)      # default 5 min
    cfg_age = ROUTING_CFG.get("max_msg_age_seconds", 3600)      # default 1 hour

    max_skew = min(max(cfg_skew, 0), _HARD_MAX_SKEW)
    max_age = min(max(cfg_age, 0), _HARD_MAX_AGE)

    # Reject timestamps far in the future (likely clock or attack)
    if msg_ts - now > max_skew:
        log_suspicious(
            "TS_FUTURE",
            peer,
            msg_id,
            "message timestamp too far in the future",
            extra={"msg_ts": msg_ts, "now": now},
        )
        raise http_error(
            status_code=400,
            code=ErrorCode.INVALID_INPUT,
            detail="message timestamp too far in the future",
            retryable=False,
        )

    # Callers can decide what to do with "too old" messages.
    if now - msg_ts > max_age:
        log_suspicious(
            "TS_OLD",
            peer,
            msg_id,
            "message too old; dropping",
            extra={"msg_ts": msg_ts, "now": now},
        )
        # we signal to caller via exception type
        raise http_error(
            status_code=200,
            code=ErrorCode.OK,  # pseudo-code; we won't actually emit this as HTTP
            detail="MESSAGE_TOO_OLD",
            retryable=False,
        )


# ---------------------------------------------------------------------------
# Startup
# ---------------------------------------------------------------------------

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    FastAPI lifespan handler to replace deprecated @app.on_event("startup").
    Runs once when the app starts.
    """
    init_db()
    asyncio.create_task(routing_loop(interval_seconds=2.0))
    yield
    # optional: add shutdown cleanup here if needed


app = FastAPI(lifespan=lifespan)

# ---------------------------------------------------------------------------
# Endpoints
# ---------------------------------------------------------------------------


@app.post("/v1/router/enqueue")
def api_enqueue(
    envelope: MessageEnvelope,
    device_fp: str = Depends(require_device_auth),
):
    """
    Gateway → Router entrypoint.

    Adds basic HTTP-layer replay + freshness checks on top of crypto.
    """
    msg_id = envelope.header.msg_id
    ttl = envelope.header.ttl

    ttl_min = ROUTING_CFG.get("ttl_min", 1)
    ttl_default = ROUTING_CFG.get("ttl_default", 4)
    ttl_max = ROUTING_CFG.get("max_ttl", 8)

    if ttl is None:
        ttl = ttl_default
        envelope.header.ttl = ttl

    if ttl < ttl_min or ttl > ttl_max:
        raise http_error(
            400,
            ErrorCode.INVALID_INPUT,
            f"ttl must be between {ttl_min} and {ttl_max}",
            retryable=False,
        )

    # HTTP-layer duplicate suppression: do not enqueue if we've seen msg_id recently
    if is_duplicate(msg_id):
        log_suspicious(
            "DUPLICATE_ENQUEUE",
            envelope.header.sender_fp,
            msg_id,
            "duplicate msg_id at enqueue; dropping",
        )
        # Not an HTTP error – we just say "not queued"
        return {"queued": False, "msg_id": msg_id, "reason": "duplicate"}

    # Timestamp freshness
    msg_ts = envelope.header.ts
    try:
        _validate_timestamp_or_raise(msg_ts, envelope.header.sender_fp, msg_id)
    except Exception as exc:
        # Special handling for "too old" pseudo-error from _validate_timestamp_or_raise
        # We treat this as a logical drop, not HTTP failure.
        if isinstance(exc, Exception) and getattr(exc, "status_code", None) == 200:
            return {"queued": False, "msg_id": msg_id, "reason": "too_old"}
        raise

    envelope.header.ttl = ttl
    envelope_json = envelope.model_dump_json()

    try:
        # we now also store sender/recipient for per-peer quotas in router_db
        enqueue_message(
            msg_id=msg_id,
            envelope_json=envelope_json,
            ttl=ttl,
            sender_fp=envelope.header.sender_fp,
            recipient_fp=envelope.header.recipient_fp,
        )
    except Exception as e:
        raise http_error(
            status_code=500,
            code=ErrorCode.DB_ERROR,
            detail=f"Failed to enqueue: {e}",
            retryable=False,
        )
    return {"queued": True, "msg_id": msg_id}


@app.get("/v1/router/outgoing_chunks")
def api_outgoing(
    limit: Optional[int] = 50,
    device_fp: str = Depends(require_device_auth_role("ble")),
):
    """
    Internal API for BLE adapter / router debugging.

    Out:
      {
        "items": [
          {
            "chunk": "<ENVELOPE_JSON_STRING>",
            "target_peer": "fingerprint-or-placeholder"
          },
          ...
        ]
      }
    """
    rows = get_outgoing()[: limit or 50]
    items = []
    for row in rows:
        items.append(
            {
                "chunk": row["envelope_json"],
                # TODO: real peer selection logic later; placeholder for now
                "target_peer": row["msg_id"],
            }
        )
    return {"items": items}


@app.post("/v1/router/mark_delivered")
def api_mark(
    payload: dict,
    device_fp: str = Depends(require_device_auth_role("ble")),
):
    """
    BLE adapter / higher layer tells router a queue row was delivered.

    In:  { "row_id": 123 }
    Out: { "ok": true }

    Errors:
      - 400 INVALID_INPUT (no row_id)
    """
    row_id = payload.get("row_id")
    if row_id is None:
        raise http_error(
            status_code=400,
            code=ErrorCode.INVALID_INPUT,
            detail="row_id required",
            retryable=False,
        )

    mark_delivered(row_id)
    return {"ok": True}


@app.post("/v1/router/on_chunk_received")
def api_on_chunk_received(
    payload: dict,
    device_fp: str = Depends(require_device_auth_role("ble")),
):
    """
    BLE → Router callback for *incoming* wireless chunks.

    In:
      {
        "chunk": <MessageEnvelope JSON>,
        "link_meta": { "rssi": -55, "peer": "fingerprint" }
      }

    Out (normal):
      { "accepted": true|false, "action": "forward|drop|final" }

    Error cases:
      - 400 INVALID_INPUT (bad envelope)
      - 410 TTL_EXPIRED (ttl <= 0)
      - 200 with accepted:false for DUPLICATE / RATE_LIMITED
    """
    link_meta = payload.get("link_meta") or {}
    peer = link_meta.get("peer", "unknown")

    try:
        env = MessageEnvelope.model_validate(payload["chunk"])
    except Exception:
        log_suspicious("INVALID_ENVELOPE", peer, "unknown", "failed to parse envelope")
        raise http_error(
            status_code=400,
            code=ErrorCode.INVALID_INPUT,
            detail="invalid envelope from BLE",
            retryable=False,
        )

    msg_id = env.header.msg_id

    # Timestamp freshness (with hard caps)
    try:
        _validate_timestamp_or_raise(env.header.ts, peer, msg_id)
    except Exception as exc:
        # "too old" is treated as logical drop, not HTTP error
        if isinstance(exc, Exception) and getattr(exc, "status_code", None) == 200:
            return {"accepted": False, "action": "drop"}
        raise

    # Normalize peer identity for IDS: trust header.sender_fp over link_meta
    header_sender = env.header.sender_fp
    if peer == "unknown":
        peer = header_sender
    elif peer != header_sender:
        # Log mismatch and still normalize to header_sender
        log_suspicious(
            "PEER_MISMATCH",
            peer,
            msg_id,
            "link_meta.peer != header.sender_fp",
            extra={"header_sender": header_sender},
        )
        peer = header_sender

    # TTL guard on ingress (defense in depth with router TTL checks)
    if env.header.ttl <= 0:
        log_suspicious("TTL_EXPIRED", peer, msg_id, "received with ttl <= 0")
        raise http_error(
            status_code=410,
            code=ErrorCode.TTL_EXPIRED,
            detail="ttl <= 0",
            retryable=False,
        )

    # Enforce TTL bounds (defensive, fail-closed) with same config as enqueue
    try:
        validate_ttl(env.header.ttl)
    except ValueError as exc:
        log_suspicious("TTL_INVALID", peer, msg_id, str(exc))
        raise http_error(
            status_code=400,
            code=ErrorCode.INVALID_INPUT,
            detail=str(exc),
            retryable=False,
        )

    # Duplicate detection – now ALWAYS enforced, not controlled by env.routing.dup_suppress
    if is_duplicate(msg_id):
        log_suspicious("DUPLICATE", peer, msg_id, "duplicate msg_id seen")
        # Not an HTTP error – this is expected behavior, we just tell BLE "drop it"
        return {"accepted": False, "action": "drop"}

    # Rate limiting per peer
    if is_rate_limited(peer):
        log_suspicious("RATE_LIMIT", peer, msg_id, "per-peer rate limit exceeded")
        # Again, logical drop, not an HTTP failure
        return {"accepted": False, "action": "drop"}

    # Phase-1 behavior: final delivery to this node only.
    # Phase-2 multi-hop behavior with one config flag.
    # Phase-2/3 could enqueue for multi-hop forwarding.
    if ROUTING_CFG.get("forwarding_enabled", False):
        return {"accepted": True, "action": "forward"}
    else:
        return {"accepted": True, "action": "final"}


@app.get("/v1/router/queue_debug")
def api_queue_debug(
    device_fp: str = Depends(require_device_auth_role("admin")),
):
    """
    Admin/debug endpoint to inspect the raw queue rows.
    """
    if not DEBUG_MODE:
        raise http_error(
            status_code=404,
            code=ErrorCode.NOT_FOUND,
            detail="endpoint disabled",
            retryable=False,
        )
    return {"items": get_outgoing()}


@app.get("/v1/router/stats")
def api_stats(
    device_fp: str = Depends(require_device_auth_role("admin")),
):
    """
    Simple stats endpoint for UI / metrics:
      - total_queued
      - total_retries
    """
    if not DEBUG_MODE:
        raise http_error(
            status_code=404,
            code=ErrorCode.NOT_FOUND,
            detail="endpoint disabled",
            retryable=False,
        )

    rows = get_outgoing()
    total = len(rows)
    retries = sum(r["retries"] for r in rows)
    return {"total_queued": total, "total_retries": retries}


@app.get("/v1/router/ids_log_tail")
def api_ids_log_tail(
    limit: int = 50,
    device_fp: str = Depends(require_device_auth_role("admin")),
):
    """
    Return last N suspicious IDS events (JSON-lines file).
    Restricted to admin role + debug mode.
    """
    if not DEBUG_MODE:
        raise http_error(
            status_code=404,
            code=ErrorCode.NOT_FOUND,
            detail="endpoint disabled",
            retryable=False,
        )

    if not IDS_LOG_PATH.exists():
        return {"events": []}

    with IDS_LOG_PATH.open("r", encoding="utf-8") as f:
        lines = f.readlines()[-limit:]

    events = [json.loads(l) for l in lines]
    return {"events": events}
